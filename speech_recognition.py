# -*- coding: utf-8 -*-
"""speech_recognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h9Vim_kns3Z2DinO6JwCs8pF6S3gwL2w
"""
# impoort libraries.
import os

import librosa
import librosa.display
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

data = []  # data list conatains .wav files of both types.
label = []  # label list containts 0 for white and 1 for asian.


# split .wav file into chunks.
def split(list_a, chunk_size):
    for i in range(0, len(list_a), chunk_size):
        yield list_a[i:i + chunk_size]


# extract feautres and concatinate them.
def concatenate_features(S, sr):
    mfcc = librosa.feature.mfcc(S, n_mfcc=12, sr=sr).flatten()
    delta_mfcc = librosa.feature.delta(mfcc).flatten()
    delta2_mfcc = librosa.feature.delta(mfcc, order=2).flatten()
    energy = librosa.feature.rms(y=S).flatten()
    delta_energy = librosa.feature.delta(energy).flatten()
    delta2_energy = librosa.feature.delta(energy, order=2).flatten()
    roll_off = librosa.feature.spectral_rolloff(y=S, sr=sr).flatten()
    feature_vector = np.concatenate((mfcc, delta_mfcc, delta2_mfcc, energy, delta_energy, delta2_energy, roll_off,),
                                    axis=0)
    return list(feature_vector)


def get_feature_vector(file_path):
    vectors = []
    S, sr = librosa.load(file_path, sr=8000)

    S = librosa.effects.trim(S)[0]
    S = librosa.util.normalize(S)

    temp = list(split(S, sr * 1 * 60))
    for vec in temp:
        vec = librosa.util.fix_length(vec, size=2 * sr * 60, mode="edge")
        vectors.append(concatenate_features(vec, sr))
    return vectors


# store .wav files and extrat them.
def process_file(dir_path, type):
    res = []
    for path in os.listdir(dir_path):
        if os.path.isfile(os.path.join(dir_path, path)):
            res.append(dir_path + '/' + path)
    for file in res:
        vectors = get_feature_vector(file)
        for vec in vectors:
            data.append(vec)
            label.append(type % 2)


def prepare_data():
    process_file(r'Data set/Training/White', 0)
    process_file(r'Data set/Training/Asian', 1)
    process_file(r'Data set/Testing/White', 2)
    process_file(r'Data set/Testing/Asian', 3)


# print confusion matrix.
def print_confusion_matrix(y_test, spam_prediction, string):
    cm = confusion_matrix(y_test, spam_prediction)
    tp = cm[0][0]
    fp = cm[0][1]
    fn = cm[1][0]
    tn = cm[1][1]
    pr = tp / (tp + fp)
    rec = tp / (tp + fn)
    print("========= The Confusion Matrix of", string, "========")
    print("           True Positive  =", tp)
    print("           False Positive =", fp)
    print("           False Negative =", fn)
    print("           True Negative  =", tn)
    print("           Precision =", round(pr * 100, 3))
    print("           Recall    =", round(rec * 100, 3))
    print("           F1-score  =", round((2 * pr * rec) / (pr + rec) * 100, 3))
    print("           Accuracy  =", round(accuracy_score(y_test, spam_prediction) * 100, 3))
    print("==============================================")


if __name__ == '__main__':
    prepare_data()
    data = np.array(data, dtype=object)
    label = np.array(label)

    data = data.astype('float32')
    label = label.astype('int')

    x_train, x_test, y_train, y_test = train_test_split(data, label, test_size=0.2, random_state=0)

    classifier = LogisticRegression()
    classifier.fit(x_train, y_train)
    sound_prediction_LR = classifier.predict(x_test)

    classifier = GaussianNB()
    classifier.fit(x_train, y_train)
    sound_prediction_GNB = classifier.predict(x_test)

    classifier = RandomForestClassifier(n_estimators=10, criterion='entropy', random_state=0)
    classifier.fit(x_train, y_train)
    sound_prediction_RF = classifier.predict(x_test)

    classifier = SVC(kernel='linear', random_state=0)
    classifier.fit(x_train, y_train)
    sound_prediction_SVC = classifier.predict(x_test)

    classifier = KNeighborsClassifier(n_neighbors=2, metric='minkowski', p=2)
    classifier.fit(x_train, y_train)
    sound_prediction_KNN = classifier.predict(x_test)

    print_confusion_matrix(y_test, sound_prediction_LR, "LR")
    print_confusion_matrix(y_test, sound_prediction_GNB, "GNB")
    print_confusion_matrix(y_test, sound_prediction_RF, "RF")
    print_confusion_matrix(y_test, sound_prediction_SVC, "SVC")
    print_confusion_matrix(y_test, sound_prediction_KNN, "KNN")


